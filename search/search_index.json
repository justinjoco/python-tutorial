{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This tutorial is intended for those who have had at least some experience coding in other languages. The goal is for readers to understand how to read and write basic to non-trival programs in Python.</p> <p>I've separated this tutorial into two parts: <code>Need to Know</code> consists of concepts that those who learn Python should know. <code>Good to Know</code> consists of supplemental features that can enhance how you use Python, but are not necessary to make non-trival programs and applications. </p> <p>I will be using Python3.6 (since this version includes \"type-hinting\") and cover introductory to intermediate Python concepts, from basic syntax to object-oriented programming. This will neither go over popular Python modules like numpy, scipy, requests, etc, nor teach data structures and algorithms fundamentals.</p> <p>Please leave your feedback here: https://forms.gle/SxPoW1JhZxGMCCfM8.</p> <p>To raise an issue on Github for feature requests or bug fixes, go here: https://github.com/justinjoco/python-tutorial/issues</p>"},{"location":"#what-is-python","title":"What is Python?","text":"<p>Python is a dynamically-typed, garbage-collected, strongly-typed, interpreted language.</p> <ul> <li>Dynamically-typed -&gt; variable types is checked at runtime, not at compile time (duck-typing)</li> <li>Garbage collected -&gt; automatic memory management</li> <li>Strongly-typed -&gt; forbids operations between distinct types (eg cannot add strings and ints together)</li> <li>Interpreted -&gt; Python source code is compiled to byte code, which is run by an interpreter (can be thought of as Python's virtual machine).</li> </ul> <p>As an FYI, CPython is Python's most widely used implementation.</p>"},{"location":"#why-use-python","title":"Why use Python?","text":"<ul> <li>It's very easy to learn, to read, and to write programs</li> <li>It supports multiple programming paradigms: concurrency, functional, generic, OOP, structural, etc.</li> <li>It can be used as a scripting language</li> <li>There are many libraries in different fields, including but limited to the following:<ul> <li>machine learning and artificial intelligence (ML/AI)</li> <li>web development</li> <li>scientific computing</li> </ul> </li> <li>There is plenty of community support, in terms of documentation and a plethora of questions asked and answered (StackOverflow is your friend).</li> </ul>"},{"location":"#why-should-i-not-use-python","title":"Why should I not use Python?","text":"<ul> <li>Python is slower compared to other lower-level languages like C, C++, Java<ul> <li>This is especially important for high-scale, traffic-heavy applications</li> <li>This is further demonstrated in that serious competitive coders almost never use Python, but instead use C, C++, Java</li> </ul> </li> <li>There is a higher likelihood of runtime errors due to weaker typing compared to stricter typed languages</li> <li>Running Python programs can consume lots of power and memory, especially for computation-intensive programs like those of machine learning</li> <li>There is a lack of UI/visual components -&gt; it is barely used for mobile computing</li> </ul>"},{"location":"#who-or-what-uses-python","title":"Who or what uses Python?","text":"<ul> <li>Python is one of the most popular programming languages of 2020</li> <li>Multiple high-profile companies use it in some of their projects:<ul> <li>NASA</li> <li>Facebook</li> <li>Google</li> <li>Amazon</li> <li>Spotify</li> </ul> </li> <li>Popular applications use it, such as:<ul> <li>Dropbox - file hosting service (originally written in Python -&gt; migrated to Go)</li> <li>SciPy - scientific computing library</li> <li>The Sims 4 - life simulation video game</li> <li>Django - MTV web framework</li> <li>Flask - web framework</li> </ul> </li> </ul>"},{"location":"#hello-world","title":"Hello World","text":"<p>Unlike lower-level programming languages, there is no requirement to make a <code>main</code> function to run a simple program. One can simply write one line of code to make a <code>Hello World</code> program, like the following: <pre><code>print(\"Hello World\")\n</code></pre> Fortunately, you can certainly make a <code>Hello World</code> program with a <code>main</code> function-like structure using the special variable <code>__name__</code>: <pre><code>def main():\n    print(\"Hello World\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> If you run a specific Python file, then that file will be treated as the <code>main</code> file, in which the following code block will run: <pre><code>if __name__ == \"__main__\":\n    main()\n</code></pre></p>"},{"location":"basics/conditionals/","title":"Conditionals","text":"<p>Code sample link: https://replit.com/@jjoco/python-conditionals</p> <p>Conditionals are used to decide whether to run different codeblocks given some condition(s). In Python, this can be accomplished using <code>if-else</code> statements. For those familiar with other languages, Python does not support <code>switch-case</code>, unfortunately.</p>"},{"location":"basics/conditionals/#if-statement","title":"If statement","text":"<p>If-statements in Python are slightly different from other language syntax. Take the following example: <pre><code>if condition:\n    #Do stuff\n</code></pre> If the <code>condition</code> is satisifed (ie is <code>True</code>), then its code block is executed.</p> <p>There are no parentheses surrounding the condition statement, and there are no curly braces wrapping the conditional code block.  Code statements that belong to the <code>if</code> code block must be indented once more with respect to the <code>if</code> statement. The following is a valid if-statement: <pre><code>count = 6\nif count &gt; 4:\n    print(\"Above 4\")\n'''\nPrints out:\nAbove 4\n'''\n</code></pre> In the following example, since <code>count</code> is greater than <code>4</code>, the program goes into the <code>if</code> code block to execute the print statement. However, in the following example: <pre><code>count = 3\nif count &gt; 4:\n    print(\"Above 4\")\n\n'''\nNothing is printed to standard output\n'''\n</code></pre> the program will simply skip the <code>if</code> statement since the <code>if</code> condition was not satisfied.</p>"},{"location":"basics/conditionals/#elif","title":"Elif","text":"<p>Python does not use <code>else if</code>; it uses <code>elif</code>, instead. <pre><code>.\n.\n.\nelif condition:\n    #Do stuff\n</code></pre></p> <p>An <code>elif</code> block must be after an <code>if</code> block, or else there will be runtime errors. Here's an example <code>if-elif</code> block:</p> <pre><code>count = 3\nif count &gt; 4:\n    print(\"Above 4\")\nelif count == 3:\n    print(\"Equal to 3\")\n\n'''\nPrints out:\n\"Equal to 3\"\n'''\n</code></pre> <p>Here, count does not satisfy the initial <code>if</code> condition; fortunately, the <code>elif</code> condition is satisfied, and its respective code block is executed. Of course, if neither the <code>if</code> nor <code>elif</code> conditions are satisfied, any code within those blocks will be skipped.</p>"},{"location":"basics/conditionals/#else","title":"Else","text":"<p>The <code>else</code> block the block executed in a bigger <code>if-else</code> block in case neither the initial <code>if</code> condition nor the subsequent <code>elif</code> conditions are met. The syntax for <code>else</code> is the following:  <pre><code>.\n.\n.\nelse:\n    #Do stuff\n</code></pre> Like <code>elif</code>,  an <code>else</code> block must be after an <code>if</code> block, or else there will be runtime errors. Here's an example <code>if-else</code> block:</p> <p><pre><code>count = 3\nif count &gt; 4:\n    print(\"Above 4\")\nelse:\n    print(\"Not above 4\")\n'''\nPrints out:\n\"Not above 4\"\n'''\n</code></pre> Since the <code>if</code> condition was not satisfied, the <code>else</code> block is executed.</p>"},{"location":"basics/conditionals/#combined-if-else","title":"Combined if-else","text":"<p><code>if</code>, <code>elif</code> and <code>else</code> can be combined like so: <pre><code>if condition_1:\n.\n.\n.\nelif condition_2:\n.\n.\n.\nelse condition_n:\n    #Do stuff\n</code></pre></p> <p>Here's an example of a combined <code>if-elif-else</code> block:</p> <p><pre><code>count = 3\nif count &gt; 4:\n    print(\"Above 4\")\nelif count == 4:\n    print(\"Equal to 4\")\nelse:\n    print(\"Less than 4\")\n</code></pre> Since neither the <code>if</code> nor the <code>elif</code> conditions are satisfied, the else block is executed.</p> <p>Note that <code>elif</code> and <code>else</code> blocks cannot exist on their own without belonging to a bigger <code>if</code> block.</p> <p>Keep in mind that you can chain several <code>elif</code> blocks: <pre><code>if condition_1:\n.\n.\n.\nelif condition_2:\n.\n.\n.\nelif condition_3:\n.\n.\n.\nelif condition_4:\n.\n.\n.\nelse condition_n:\n    #Do stuff\n</code></pre> Here's an example with multiple <code>elif</code>'s choosing what letter grade to print out given a test grade: <pre><code>test_grade = 70\nif test_grade &gt;= 90:\n    print(\"A\")\nelif test_grade &gt;= 80:\n    print(\"B\")\nelif test_grade &gt;= 70:\n    print(\"C\")\nelif test_grade &gt;= 60:\n    print(\"D\")\nelse:\n    print(\"F\")\n'''\nPrints out:\nC\n'''\n</code></pre></p>"},{"location":"basics/conditionals/#multiple-condition-checking","title":"Multiple condition checking","text":"<p>In Python, you can check multiple conditions in an <code>if</code> or <code>elif</code> before deciding to execute its respective code block. Important keywords are logical operators <code>and</code>, <code>or</code>, and <code>not</code>. </p>"},{"location":"basics/conditionals/#and","title":"<code>and</code>","text":"<p>If you want two conditions to be met before executing a block, use the <code>and</code> keyword (<code>&amp;&amp;</code> in other languages).</p> <p>Syntax: <pre><code>if condition_1 and condition_2:\n    #Do stuff\n</code></pre> Let's say we wanted if I should order takeout based on my energy levels and the amount of food I already have in my fridge: <pre><code>energy_levels = 20\nfridge_content = 10\nif energy_levels &lt; 30 and fridge_content &lt; 30 :\n    print(\"Order delivery\")\n\n'''\nPrints out:\nOrder delivery\n'''\n</code></pre> Since both conditions are satisfied, the <code>if</code> block is executed. Because I'm too low energy and don't have enough stuff in my fridge, I decide to order takeout. </p>"},{"location":"basics/conditionals/#or","title":"<code>or</code>","text":"<p>If you want either of two conditions to meet before executing a code block, use <code>or</code>  (<code>||</code> in other languages). </p> <p>Syntax: <pre><code>if condition_1 or condition_2:\n    #Do stuff\n</code></pre> In the following example, I decide if I should rest depending on the period of the day and my energy levels. <pre><code>energy_levels = 5\nperiod_of_day = \"afternoon\"\nif period_of_day == \"midnight\" or energy_levels &lt; 10 :\n    print(\"Go rest\")\n'''\nPrints out:\nGo rest\n'''\n</code></pre> In the above example, even though only one of the conditions was satisfied, the <code>if</code> block is executed. Even though it's the afternoon, my energy levels are low enough, such that I decide to rest.</p>"},{"location":"basics/conditionals/#not","title":"<code>not</code>","text":"<p>If you don't want a condition to be met before executing a code block, use <code>not</code>  (<code>!</code> in other languages).</p> <p>Syntax: <pre><code>if not condition:\n    #Do stuff\n</code></pre> To translate the decision to go outside only if the weather condition is not raining, we can do the following: <pre><code>weather = \"sunny\"\nif not weather == \"raining\":\n    print(\"Go outside\")\n'''\nPrints out:\nGo outside\n'''\n</code></pre> Obviously, if I initially set <code>weather = \"raining\"</code>, then that code block would not execute.</p>"},{"location":"basics/conditionals/#mixing-multiple-logical-operators","title":"Mixing multiple logical operators","text":"<p>You can have multiple logical operators in the same conditional line; use parentheses to denote which logical comparisons should take priority over others; an abstract example can look like: <pre><code>if (condition_1 or condition_2) and (condition_3 or condition_4):\n    #Do stuff\n</code></pre> Or look like  <pre><code>if (condition_1 and condition_2) or (condition_3 or condition_4):\n    #Do stuff\n</code></pre> In both of these examples, the result of the parentheses are calculated first, then the results are compared: <pre><code>if condition_1_2 or condition_3_4:\n    #Do stuff\n</code></pre>  This example can continue ad infintum.</p>"},{"location":"basics/exceptions/","title":"Exception Handling","text":"<p>Code sample link: https://replit.com/@jjoco/python-exceptions</p> <p>Let's say you wanted to execute some block of code, that could potentially throw an error (specifically called Exceptions). Normally, if a block of code throws an error, the currently executing program would crash. To prevent this from happening, one can wrap such block of code using <code>try-except</code> blocks, which are <code>try-catch</code> blocks in many other languages.</p>"},{"location":"basics/exceptions/#basic-try-except","title":"Basic try-except","text":"<p>The syntax for <code>try-except</code> is the following: <pre><code>try:\n    #Do stuff\nexcept:\n    #Do when an exception is thrown\n</code></pre> The idea is that if a block of code within the <code>try</code> block throws an Exception, then the program will execute an <code>except</code> block to handle the Exception.</p> <p>If the dev wants to do something with the Exception caught, then they can use the following syntax: <pre><code>try:\n    #Do stuff\nexcept Exception as err: #Creates alias for Exception object, which dev can do stuff with\n    #Do when an exception is thrown\n</code></pre></p> <p>If it's possible that the try block can throw different types of Exceptions, then the <code>try-except</code> can have multiple <code>except</code> blocks, which execute when a specific Exception type is thrown:</p>"},{"location":"basics/exceptions/#try-except-with-muiltiple-excepts","title":"Try-except with muiltiple excepts","text":"<pre><code>try:\n    #Do stuff\nexcept ValueError:\n    #Do when ValueError exception is thrown\nexcept KeyError:\n    #Do when KeyError exception is thrown\n</code></pre> <p>The dev can also handle different Exceptions in the same <code>except</code> block like the following:</p>"},{"location":"basics/exceptions/#try-except-with-multiple-exception-types-on-one-line","title":"Try-except with multiple exception types on one line","text":"<pre><code>try:\n    #Do stuff\nexcept ValueError, KeyError:\n    #Do when ValueError or a KeyError exception is thrown\nexcept ZeroDivisionError:\n    #Do when ZeroDivisionError exception is thrown\nexcept Exception:\n    #Do when any other exception is thrown\n</code></pre>"},{"location":"basics/exceptions/#finally","title":"Finally","text":"<p>Finally, there's the <code>finally</code> block, which generally executes right before the <code>try</code> statement completes: <pre><code>try:\n    #Do stuff\nexcept ValueError, KeyError:\n    #Do when ValueError or a KeyError exception is thrown\nexcept ZeroDivisionError:\n    #Do when ZeroDivisionError exception is thrown\nfinally:\n    #Do stuff before try finishes\n</code></pre></p> <p>So if a <code>try-finally</code> block looks like this: <pre><code>try:\n    raise Exception\nfinally:\n    print(\"Finally clause here\")\n</code></pre> Then, standard output would show <code>Finally clause here</code> followed by the <code>Exception</code>.</p> <p>There are other complexities involving this <code>finally</code> block, but that's out of the scope of this tutorial.</p>"},{"location":"basics/functions/","title":"Functions","text":"<p>Code sample link: https://replit.com/@jjoco/python-functions</p> <p>Functions are like any mathematical function: you put something in, the function does something with your input, and you get something out. In Python, the keyword for defining a function is <code>def</code>, followed by a function name with parameters.</p>"},{"location":"basics/functions/#defining-a-function","title":"Defining a function","text":"<pre><code>def function_name(input1 , ...):\n   # Do stuff\n</code></pre> <p>Function inputs and outputs need not have type hints; however, it is generally good code convention to have types hinted, anyway: <pre><code>def function_name(input1: type1 , input2: type2 ...) -&gt; return_type:\n   # Do stuff\n</code></pre></p>"},{"location":"basics/functions/#calling-a-function","title":"Calling a function","text":"<p>To call a function, use the following syntax <pre><code>function_name(input1, input2)\n</code></pre> What this is doing is invoking a function to do work on the given inputs. If the function is set to return some output, then the calling function can retrieve the output value like so: <pre><code>var_1 = function_name(input1, input2)\n</code></pre> Then, the dev can use the value set in var_1 to do whatever they want.</p> <p>Let's go through a more concrete example. Let's say I wanted to create a function that doubled the original value inputted. It's obviously bad practice to have a function name be something vague like  <pre><code>def a():\n    #Do stuff\n</code></pre></p> <p>It is very good coding practice to be precise with your function names, especially in bigger projects. Let's implement the doubling function: <pre><code>def double(x):\n    return x*2\n</code></pre> We take an input <code>x</code> value and return <code>x</code> multipled by two. We can call <code>double</code> somewhere else, like the following: <pre><code>doubled = double(5)\n# doubled == 10\n</code></pre> For those wondering, you can call a given function within itself: <pre><code>def some_function(x):\n    .\n    .\n    .\n    some_function(x)\n</code></pre> This is called a recursive function, in which a function calls itself at some point within its implementation. However, I will not be going over these type of functions in this tutorial.</p>"},{"location":"basics/importing/","title":"Importing Modules","text":"<p>Code sample link: https://replit.com/@jjoco/python-importing</p> <p>If Python does not contain functionality for something you want to do, you can import libraries that implement these functions, assuming such libraries exist.</p>"},{"location":"basics/importing/#importing-a-library","title":"Importing a library","text":"<p>To import a library, one can use the <code>import</code> keyword. Take the following example, in which<code>numpy</code>, a popular scientific computing, library  is imported. <pre><code>import numpy\n</code></pre> Then, you can invoke the <code>array</code> function within this library, like so: <pre><code>numpy.array([3.5,2.4,1.0])\n</code></pre></p>"},{"location":"basics/importing/#library-aliasing","title":"Library aliasing","text":"<p>In case the library's name is too long or too vague, one can use alias the library: <pre><code>import numpy as np\n</code></pre> Instead of using <code>numpy</code> when invoking a function, the dev can use <code>np</code> instead. So, what would originally have been <code>numpy.array()</code> would turn into <code>np.array()</code>: <pre><code>np.array([3.5,2.4,1.0])\n</code></pre></p>"},{"location":"basics/importing/#importing-something-from-a-library","title":"Importing something from a library","text":"<p>You can import specific functions or constants from the imported libraries, like so <pre><code>from math import pi\n\nprint(pi)\n</code></pre> <pre><code>import math\nprint(math.pi)\n</code></pre> It is a neat feature to use in case you don't want to write the library name every time you invoke a function from it.</p>"},{"location":"basics/looping/","title":"Looping","text":"<p>Code sample link: https://replit.com/@jjoco/python-looping</p> <p>Looping in Python is used to execute a given set of code repeatedly. There are two ways to loop in Python: <code>for</code> loops and <code>while</code> loops.</p>"},{"location":"basics/looping/#for-loop","title":"For loop","text":"<p>The <code>for</code> keyword is used to iterate over an sequence or some iterable type. </p> <p>The general syntax for simple <code>for</code> loops is the following: <pre><code>for elem in &lt;iterable&gt;:\n    #Do stuff to elem\n</code></pre> When the <code>for</code> loop iterates through the iterable, the value at a given point in the iterable is written into <code>elem</code> (which you can name to whatever you want, by the way). On each iteration, you'll be able to process each element in the iterable.</p> <p>Let's go through several examples.</p>"},{"location":"basics/looping/#iterate-through-string","title":"Iterate through string","text":"<p>We can process each character in a given string: <pre><code>string_var = \"asdfjk;\"\nfor char in string_var:\n    print(char)\n'''\nPrints out:\na\ns\nd\nf\nj\nk\n;\n'''\n</code></pre></p>"},{"location":"basics/looping/#iterate-through-list","title":"Iterate through list","text":"<p>Think of lists as an ordered sequence of values, like <code>1, 5, 6, 7</code> in that order. We'll go over lists in-depth in the <code>Lists</code> section under the <code>Collections</code> header.</p> <p>We can iterate through each value in the list like the following: <pre><code>list_var = [4, 5, 6, 7]\nfor element in list_var:\n    #Process element\n</code></pre></p>"},{"location":"basics/looping/#iterate-through-a-range-of-ints","title":"Iterate through a range of ints","text":"<p>In other languages, to iterate through lists or arrays, the most common way is to use array indices to access array values. The key is to use Python's in-built <code>range()</code> function, which returns a sequence of integers for <code>0</code> to <code>n-1</code> if you use the <code>range(n)</code> signature: <pre><code>for i in range(n):\n    #Process i\n</code></pre> But in case you want to set the sequence's start value, you can use the signature <code>range(start, stop)</code>, in which a sequence of numbers from <code>start</code> to <code>stop-1</code> is returned. If you want to include the step, as well, use <code>range(start, stop, step)</code>, which returns a sequence of numbers from <code>start</code> to <code>stop-1</code> in steps of <code>step</code>: <pre><code>for i in range(-1, 5):\n    print(i)\n'''\nPrints out:\n-1\n0\n1\n2\n3\n4\n'''\n\nfor i in range(0, 10, 2):\n    print(i)\n'''\nPrints out:\n0\n2\n4\n6\n8\n'''\n</code></pre></p> <p>So, to iterate through all elements in a list via indices, you'll have to input the length of the list as the argument in the <code>range(n)</code> function: <pre><code>for i in range(len(list_var)):\n  #  Do stuff to listVar[i]\n  print(list_var[i])\n</code></pre></p>"},{"location":"basics/looping/#while-loop","title":"While loop","text":"<p>One can use <code>while</code> loops to execute code repeatedly. The syntax is follows: <pre><code>while condition:\n   # Do stuff\n</code></pre></p> <p>So, let's say we have a counter that continues incrementing from <code>0</code> until <code>5</code>. We can write: <pre><code>counter = 0\n\nwhile counter &lt; 5:\n    print(counter)\n    counter+=1\n'''\nPrints out:\n0\n1\n2\n3\n4\n'''\n</code></pre> The while continues to execute the increment statement until the counter becomes <code>5</code>, at which the program exits the while loop.</p> <p>For those wondering, you can write the same <code>for</code> loop as a <code>while</code> or vice-versa. Generally, I use for-loops when iterating through something or the number of iterations can be known ahead of time; on the other hand, I use while-loops when my looping is dependent on some condition or the number of iterations is variable. For example, you shouldn't use a for-loop to write an infinite loop.</p>"},{"location":"basics/looping/#infinite-loop","title":"Infinite loop","text":"<p>The easiest way to write an infinite loop is via a while loop: <pre><code>while True:\n   # Do stuff forever or until break\n</code></pre> You would want to use an infinite loop if your program is intended to run forever, like a server. However, you can write your infinite loop to end prematurely if some condition is met during the loop execution. In this case, you would use the <code>break</code> statement to exit the loop. You can use <code>break</code> in either a for-loop or a while-loop to exit the current loop block.</p> <p><pre><code>while True:\n   # Do stuff forever or until break\n   x = int(input(\"Enter a number: \"))\n\n   if x == -1:\n       break\n</code></pre> In the above example, the while-loop executes forever, asking the user to input a number. Assuming the user always inputs a number, the while-loop ends if the user inputs a <code>-1</code>.</p>"},{"location":"basics/syntax/","title":"Syntax","text":"<p>Code sample link: https://replit.com/@jjoco/python-syntax</p> <p>One of Python's main features is its readability. Consider the following pseudocode:</p> <p><pre><code>if there is no milk and the store is open,\n  buy milk\n</code></pre> The above pseudocode can be translated into the following Python code: <pre><code>if not have_milk and is_store_open:\n  buy_milk()\n</code></pre></p> <p>Compared to to other languages, there is no curly brackets to wrap code code blocks; instead, Python interprets code blocks via colons and indentation.</p>"},{"location":"basics/syntax/#indentation","title":"Indentation","text":"<p>Statements are interpreted in Python based on how indented they are. Unlike other programming languages in which indentation is technically optional, indentation in Python is used to interpret blocks of code. Take the following example: <pre><code>if True:\n  print(\"Outside true\")\n  if True:\n    print(\"Nested true\")\n    if True:\n      print(\"Nested nested true\")\n</code></pre> As you can see, nested indentation shows nested blocks of code. Running improperly indented code will cause Python interpreter errors.</p>"},{"location":"basics/syntax/#comments","title":"Comments","text":"<p>Like in other languages, comments are implemented in Python to denote statements that are not to be interpreted and are for developer documentation. Single line comments are written like the following with the <code>#</code> prefix: <pre><code># This is a single line comment\n</code></pre> Multiline comments are wrapped with triple single or double quotes: <pre><code>'''\nThis is a multiline\ncomment with single quotes\n'''\n\"\"\"\nThis is a multiline\ncomment with double quotes\n\"\"\"\n</code></pre></p>"},{"location":"basics/vars/","title":"Variables and Data Types","text":""},{"location":"basics/vars/#primitive-data-types","title":"Primitive data types","text":"<p>Python includes many primitive data types like many other languages.</p> <ul> <li>String<ul> <li><code>str</code></li> </ul> </li> <li>Number types<ul> <li><code>int</code></li> <li><code>float</code></li> <li><code>complex</code></li> </ul> </li> <li>Boolean types<ul> <li><code>bool</code></li> </ul> </li> </ul> <p>Notice that there is no <code>char</code> data type to represent a character-type.</p>"},{"location":"basics/vars/#assigning-variables","title":"Assigning variables","text":"<p>Code sample link: https://replit.com/@jjoco/python-vars</p> <p>Like in all other programming languages, data types can be assigned to variables. Since Python is not statically typed, there is no need to type a variable before running Python code. Consider the following: <pre><code>countNoType = 5\n</code></pre> If a variable is assigned to a literal, the interpreter will figure out the type of the variable based on the literal used, an integer in this case.</p>"},{"location":"basics/vars/#type-hinting","title":"Type hinting","text":"<p>Starting from Python 3.5, developers can hint to the data type used for a variable, like so: <pre><code>countWithType: int = 3\n</code></pre> However, this is not exactly the same as static typing; Python3 will not enforce that the literal assigned to a variable will be the same as the type hint. For example, a valid statement that can run with no Python interpreter errors can be <pre><code>countWithType: int = \"hello\"\n</code></pre></p>"},{"location":"basics/vars/#operators","title":"Operators","text":"<p>Code sample link: https://replit.com/@jjoco/python-operators</p> <p>In Python, there are different operators between two operands: arithmetic, logical, and assignment.</p>"},{"location":"basics/vars/#arithmetic","title":"Arithmetic","text":"<p>Python supports arithmetic between two variables:</p> <ul> <li>Addition: <code>+</code> : <code>x + y</code> --&gt; <code>(5 + 2) == 7</code> </li> <li>Subtraction: <code>-</code>:  <code>x - y</code> --&gt; <code>(5 - 2) == 3</code> </li> <li>Multiplication: <code>*</code>:  <code>x * y</code> --&gt; <code>(5 * 2) == 10</code> </li> <li>Division: <code>/</code>: <code>x / y</code> --&gt; <code>(5 / 2) == 2.5</code> </li> <li>Floor (Integer) Division <code>//</code>: <code>x // y</code> --&gt; <code>(5 // 2) == 2</code> </li> <li>Modulo (Remainder) <code>%</code>: <code>x % y</code> --&gt; <code>(5 % 2) == 1</code> </li> <li>Exponent <code>**</code>: <code>x**y</code> --&gt; <code>(5 ** 3) == 125</code> </li> </ul>"},{"location":"basics/vars/#logical","title":"Logical","text":"<p>Comparison operators between two operands are supported</p> <ul> <li>Less than <code>&lt;</code>: <code>x &lt; y</code> --&gt; <code>(5 &lt; 2) == False</code> </li> <li>Less than or equal to <code>&lt;=</code>: <code>x &lt;= y</code> --&gt; <code>(5 &lt;= 2) == False</code> </li> <li>Equal to <code>==</code>: <code>x == y</code> --&gt; <code>(5 == 2) == False</code> </li> <li>Greater than or equal to <code>&gt;=</code>: <code>x &gt;= y</code> --&gt; <code>(5 &gt;= 2) == True</code> </li> <li>Greater than <code>&gt;</code>: <code>x &gt; y</code> --&gt; <code>(5 &gt; 2) == True</code> </li> <li>Not equal <code>!=</code>: <code>x != y</code> --&gt; <code>(5 != 2) == True</code> </li> </ul>"},{"location":"basics/vars/#arithmetic-assignment-operators","title":"Arithmetic assignment operators","text":"<p>Assigning a variable the result of an arithmetic operation between the variable's previous value and another operand is supported.</p> <ul> <li>Add, then assign: <code>+=</code>: <code>x += y</code> </li> <li>Subtract, then assign <code>-=</code>: <code>x -= y</code></li> <li>Multiply, then assign <code>*=</code>: <code>x *= y</code></li> <li>Divide, then assign <code>/=</code>: <code>x /= y</code></li> <li>Modulo, then assign: <code>%=</code>: <code>x %= y</code></li> </ul> <p>Unlike other languages, Python does not support the increment (ie <code>++</code>) or decrement (<code>--</code>) operators. You need to use <code>+=1</code> or <code>-=1</code> on the accumulator.</p>"},{"location":"basics/vars/#bitwise","title":"Bitwise","text":"<p>Operations between numbers on a bit-level are supported.</p> <ul> <li>Bitwise AND <code>&amp;</code></li> <li>Bitwise OR <code>|</code></li> <li>Bitwise XOR <code>^</code></li> <li>Bitwise NOT <code>~</code></li> <li>Bitwise left shift <code>&lt;&lt;</code></li> <li>Bitwise right shift <code>&gt;&gt;</code></li> </ul>"},{"location":"collections/comprehensions/","title":"Comprehensions","text":"<p>Code sample link: https://replit.com/@jjoco/python-comprehensions</p> <p>Comprehensions is a neat Python feature that allows the creation of new collections (ie. data structures that contain elements, such as lists, dictionaries, etc.) from previously-made collections in a syntactically concise way. We will cover list, dictionary, and set comprehensions in this tutorial.</p>"},{"location":"collections/comprehensions/#list-comprehensions","title":"List comprehensions","text":"<p>List comprehensions allows the creation of new lists from other collections. The general syntax is the following: <pre><code>#From list\nnew_list = [some_function(elem) for elem in some_list if condition]\n\n#From dictionary\nnew_list_from = [some_function(key, value) for key, value in some_map.items() if condition]\n</code></pre> What's happening is that elements in a base collection (that satisfy the given condition) are passed into a function, and the output values of the function become the elements of the new list.</p> <p>In the following example, we use list comprehension syntax to create a list of integers that contains cubed values of even numbers of a base list, and another that contains doubled values of the same list: <pre><code>def pow(x: float, n: int) -&gt; float:\n  return x ** n\n\nbase_list = [2, 3, 4, 6, 7, 3, 2]\n\npow_list = [pow(num, 2) for num in base_list if num%2 ==0]\nprint(pow_list) # [4, 16, 36, 4]\n\ndoubled_list = [num*2 for num in base_list]\nprint(doubled_list) # [4, 6, 8, 12, 14, 6, 4]\n</code></pre></p>"},{"location":"collections/comprehensions/#dictionary-comprehensions","title":"Dictionary comprehensions","text":"<p>Similarly to list comprehensions, we can create a new dictionary from a collection using the following syntax: <pre><code>#From list\nmy_map = {key_func(elem) : value_func(elem) for elem in some_list if condition}\n\n#From dict\nmy_map = {key_func(prev_key) : value_func(prev_value) for prev_key, prev_value in base_map.items() if condition}\n</code></pre> What's happening here is that we use the items (that satisfy a given condition, if provided) in the given collection to create the key-value pairs in our new dictionary.</p> <p>Take the following example: <pre><code>#From list\nbase_list = [2, 3, 4, 6, 7, 3, 2]\ncubed_map = {x : x**3 for x in base_list}\nprint(cubed_map) # {2: 8, 3: 27, 4: 64, 6: 216, 7: 343}\n\n#From dict\nbase_map = {\"ace\": 11, \"king\": 12, \"queen\": 13, \"jack\": 14}\ncard_rev_map = { card[:-1] : value+4 for card, value in base_map.items() if len(key) &gt;= 4}\nprint(card_rev_map) # {'kin': 16, 'quee': 17, 'jac': 18}\n</code></pre> In the dictionary comprehension that is based off a list, we create a dictionary that maps the numbers of <code>base_list</code> to their cubed values. In the dictionary-based dictionary comprehension, we create a new map that contains the shortened face card names their incremented card values, given the original card names were at least 4 characters long.</p>"},{"location":"collections/comprehensions/#set-comprehensions","title":"Set comprehensions","text":"<p>Set comprehension syntax is the same as that of list comprehension, except with curly braces. <pre><code>#From list\nmy_set = {some_func(elem) for elem in some_list if condition}\n\n#From dict\nmy_set = {some_func(key, value) for key, value in base_map.items() if condition}\n</code></pre> We use the items (that satisfy a given condition, if provided) in the given collection to create values in our new set.</p> <p>Consider the following: <pre><code>#From list or set\nbase_list = [2, 3, 4, 6, 7, 3, 2]\ncubed_set = {x**3 for x in base_list}\nprint(cubed_set) #{64, 8, 343, 216, 27}\n\n#From dict\nmy_map = {5:7, 3:6, 2:8}\nadd_set = {key+value for key, value in my_map.items() if value % key == 0}\nprint(add_set) #{9, 10}\n</code></pre> In the first example, we create a set of cubed values based on values of <code>base_list</code>. In the second, we create a new set, whose values are the sum of key-value pairs in <code>my_map</code>, given that a pair's value is a multiple of its key.</p>"},{"location":"collections/dictionaries/","title":"Dictionaries","text":"<p>Code sample link: https://replit.com/@jjoco/python-dictionaries</p> <p>When you go to the grocery store, each item in the store has an associated price tag to it. You can easily associate an item with a price Python's in-built data structure: the dictionary. </p> <p>Dictionaries are data structures that maps keys to values. Like lists, these maintain a running record of elements. Unlike lists, these store key-value pairs, and keys cannot be duplicated, but multiple keys can have the same value. For those familiar in other programming languages, dictionaries are Python's hashtables and hashmaps.</p> <p>With a dictionary, you can quickly find the price of specific item, or update the price of another item without needing to look through the entire grocery inventory. To be more technical, dictionary reads and writes have <code>O(1)</code> time complexity. A very simple item-price dictionary can look like the following: <pre><code>{\"banana\": 3.99, \"bread\": 2.99, \"salmon\": 10.99, \"onion\": 1.99}\n</code></pre></p> <p>For the rest of the tutorial, I will be using <code>_map</code> as variable names for dictionary types, as associative key-value structures are generally called <code>maps</code> in other languages. In Python 3.6 and later versions, dictionaries maintain element insertion order, so you need not use <code>OrderedDict</code> to maintain an ordered dictionary, though it may be helpful for readability. </p>"},{"location":"collections/dictionaries/#creating-a-dictionary","title":"Creating a dictionary","text":"<p>To create a dictionary, use curly braces: <pre><code># Empty dictionary\nmy_map = {}\n\n# Populated dictionary\ngrocery_map = {\"banana\": 3.99, \"bread\": 2.99, \"salmon\": 10.99, \"onion\": 1.99}\n</code></pre></p> <p>Like any other data structure, you can type-hint a dictionary's keys and values using syntax <code>some_map: Dict[KeyType, ValueType]</code>: <pre><code>from typing import Dict\ngrocery_map: Dict[str, float] = {\"banana\": 3.99, \"bread\": 2.99, \"salmon\": 10.99, \"onion\": 1.99}\n</code></pre></p>"},{"location":"collections/dictionaries/#setting-dictionary-elements","title":"Setting dictionary elements","text":"<p>Like I alluded to earlier, you can easily add a new key-value pair to the dictionary or update the value of a given key, like the following: <pre><code>grocery_map[\"chicken_breast\"] = 5.99\ngrocery_map[\"banana\"] = 1.00\ngrocery_map[\"bread\"] = 9.00\n</code></pre></p>"},{"location":"collections/dictionaries/#getting-a-dictionary-element","title":"Getting a dictionary element","text":"<p>You can also get the value of a given key: <pre><code>banana_price = grocery_map[\"banana\"]\nbanana_price_with_get = grocery_map.get(\"banana\") \n</code></pre> Note that if a key-value pair does not exist, then <code>grocery_map[\"banana\"]</code> would throw an KeyError exception; whereas, <code>grocery_map.get(\"banana\")</code> will return a <code>None</code> type.</p>"},{"location":"collections/dictionaries/#getting-the-length-of-a-dictionary","title":"Getting the length of a dictionary","text":"<p>You can use <code>len</code> to get the number of key-value pairs in a dictionary (ie. its length) . <pre><code>dictionary_length = len(my_dictionary)\n</code></pre> So, if <code>grocery_map = {\"banana\": 3.99, \"bread\": 2.99, \"salmon\": 10.99, \"onion\": 1.99}</code>, then <code>len(grocery_map)</code> would be <code>4</code>.</p>"},{"location":"collections/dictionaries/#iterate-through-dictionary-elements","title":"Iterate through dictionary elements","text":"<p>There are several ways to iterate through dictionaries.</p>"},{"location":"collections/dictionaries/#via-simple-iteration","title":"Via simple iteration","text":"<p>Using the following syntax, we can iterate through the keys of a dictionary: <pre><code>for key in grocery_map:\n  print(grocery_map[key])\n</code></pre></p>"},{"location":"collections/dictionaries/#via-items","title":"Via <code>.items()</code>","text":"<p>Fortunately in Python, we can iterate through a dictionary's keys and values more cleanly via dictionary.items() (the function name is completely unrelated to the grocery store theme): <pre><code>for key, value in grocery_map.items():\n    #Do stuff to key and value\n</code></pre> Here, we can process the key and value of a pair simultaneously. Note that those variables need not be named <code>key</code>, <code>value</code>; since we're using a grocery store theme, we can rewrite the above as the following: <pre><code>for item, price in grocery_map.items():\n    #Do stuff to key and value\n</code></pre></p> <p>To be a bit more technical, elements in dictionary.items() are 2-tuples (immutable array data structures with only two elements), and one can iterate through the 0th and 1st index of that tuple to grab the key and value, respectively. <pre><code>for item in grocery_map.items():\n  key = item[0]\n  value = item[1]\n  print(\"Item: \", item) # Item: (&lt;key&gt;, &lt;value&gt;)\n</code></pre> However, this approach is not readable and more tedious to write than the ealier <code>key, value</code> syntax, in which we're unpacking the tuple element into <code>key</code> and <code>value</code>.</p>"},{"location":"collections/dictionaries/#via-keys","title":"Via <code>.keys()</code>","text":"<p>We can iterate through only the keys of the dictionary. <pre><code>for key in grocery_map.keys():\n  print(key)\n</code></pre></p>"},{"location":"collections/dictionaries/#via-values","title":"Via <code>.values()</code>","text":"<p>We can also iterate through only the values of the dictionary. <pre><code>for value in grocery_map.values():\n  print(value)\n</code></pre></p>"},{"location":"collections/dictionaries/#deleting-a-dictionary-key-value-pair","title":"Deleting a dictionary key-value pair","text":"<p>One can delete a key-value pair by only knowing the key. <pre><code>del grocery_map[\"banana\"]\n</code></pre></p>"},{"location":"collections/lists/","title":"Lists","text":"<p>Code sample link: https://replit.com/@jjoco/python-lists</p> <p>In Python, lists are used to keep a record of values of a specific data type in an ordered way, each of which can be processed. Lists can contain duplicates of the same value. These can be thought of as arrays in other languages, but more function similarly to <code>ArrayLists</code> in Java. Python lists start indexing at 0.</p>"},{"location":"collections/lists/#creating-a-list","title":"Creating a list","text":"<p>To create an empty list, one can use square brackets <code>[]</code>, like so: <pre><code>my_list = []\n</code></pre> This empty list, as the name suggests, contains no elements within it. This is can be used to initalize a list that will be modified later on.</p> <p>One can also type hint a list; to type hint the list of strings, one can write the following <pre><code>from typing import List\n\n.\n.\n.\nmy_list : List[str] = []\n</code></pre> A list need not have to be empty every time when intialized. Lists can be initialized with elements inside, like so: <pre><code>my_list = [\"hello\", \"there\", \"my\", \"name\", \"is\"]\n</code></pre></p> <p>Unlike strictly typed languages, Python allows lists to contain more than one type. For example, the following multi-type list is valid in Python: <pre><code>my_list = [\"hello\", 0, 1.5 , \"name\", True]\n</code></pre> The above example contains strings, an integer, a float, and a boolean; strictly-typed languages forbid multi-type arrays and will throw a compile time error (if an array is initalized like above) or during runtime (if an element to be added is not of the same type as that already in the array).</p> <p>Even if a developer type hints, the multi-type list is still a valid list, like so: <pre><code>my_list: List[str] = [\"hello\", 0, 1.5 , \"name\", True]\n</code></pre> If it is critical that a list is not to contain multiple types, do not rely on the Python interpreter out-of-the-box to prevent multi-type lists.</p> <p>A cool feature is that one can create a list of a certain size, with all values initialized. For example, to create a list of size 7 filled with <code>None</code>, you can write the following: <pre><code>occupied_list = [None] * 7\n# occupied_list == [None, None, None, None, None, None, None]\n</code></pre></p>"},{"location":"collections/lists/#iterating-through-a-list","title":"Iterating through a list","text":"<p>The Python way of iterating through a list is very similar to how other languages use iterator looping.</p> <pre><code>for elem in my_list:\n    #Do stuff to elem\n</code></pre> <p>Let's say I wanted to print out the elements in a given list. You can do the following: <pre><code>hello_list = [\"hello\", \"world\", \"!\"]\nfor elem in hello_list:\n  print(elem)\n'''\nPrints out:\nhello\nworld\n!\n'''\n</code></pre></p>"},{"location":"collections/lists/#iterating-through-a-list-via-enumerate","title":"Iterating through a list via enumerate","text":"<p>Sample: https://replit.com/@jjoco/python-enumerate</p> <p>Python has a special function called <code>enumerate</code>. <code>enumerate</code>'s parameter is a list, and it returns an enumeration of the list that allows a dev to loop through a list's indicies and elements simultaneously. </p> <pre><code>my_list = [2, 21, 7, 8, 65 ,9 , 0]\n\nfor index, value in enumerate(my_list):\n  print(\"Index: \", index)\n  print(\"Value: \", value)\n'''\nPrints out:\nIndex:  0\nValue:  2\nIndex:  1\nValue:  21\nIndex:  2\nValue:  7\nIndex:  3\nValue:  8\nIndex:  4\nValue:  65\nIndex:  5\nValue:  9\nIndex:  6\nValue:  0\n'''\n</code></pre> <p>In case the value of an element does not matter, a dev can use an underscore <code>_</code> in place of the value to denote a <code>dont-care</code>. <pre><code>for jndex, _ in enumerate(my_list):\n  print(\"jndex: \", jndex)\n'''\nPrints out:\njndex:  0\njndex:  1\njndex:  2\njndex:  3\njndex:  4\njndex:  5\njndex:  6\n'''\n</code></pre></p> <p>Likewise if the index of an element does not matter, use an underscore in place of the index. <pre><code>for _, value in enumerate(my_list):\n  print(\"Value: \", value)\n'''\nValue:  2\nValue:  21\nValue:  7\nValue:  8\nValue:  65\nValue:  9\nValue:  0\n'''\n</code></pre></p>"},{"location":"collections/lists/#setting-a-list-element","title":"Setting a list element","text":"<p>A dev can set the value of an element as a given index like the following.</p> <p><pre><code>my_list = [2, 21, 7, 8, 65 ,9 , 0]\nmy_list[3] = 5\n</code></pre> The above line sets the element at index 3 (whose value is 8) to 5. Keep in mind that if the input index is outside the scope of the list, then Python will throw an <code>IndexOutOfRangeException</code>. </p>"},{"location":"collections/lists/#getting-a-list-element","title":"Getting a list element","text":"<p>To get an element at a given index, use the following syntax: <pre><code>elem = my_list[index]\n</code></pre> Let's say we wanted to print the value of <code>my_list = [2, 21, 7, 8, 65 ,9 , 0]</code> at index 2, we can write: <pre><code>print(my_list[2])\n#Output = 7\n</code></pre></p>"},{"location":"collections/lists/#getting-the-length-of-a-list","title":"Getting the length of a list","text":"<p>To get the number of elements in a list (ie. its length), use the <code>len</code> function: <pre><code>list_length = len(my_list)\n</code></pre> So, if <code>my_list = [2, 21, 7, 8, 65 ,9 , 0]</code>, then <code>len(my_list)</code> would be <code>7</code>.</p>"},{"location":"collections/lists/#iterating-through-a-list-via-range","title":"Iterating through a list via range","text":"<p>Devs can also iterate through a list via indices, but they still need to use the iterator syntax mentioned earlier using a special function <code>range(n)</code>. <code>range(n)</code> returns a sequence of numbers from <code>0</code> to <code>n-1</code>. To iterate through an entire list using <code>range</code>, input the length of the list as its parameter. <pre><code>bigger_list = [1,5,8,3,8,0,3]\n\nfor i in range(len(bigger_list)):\n  print(bigger_list[i])\n</code></pre> Try not to iterate through lists like this too often unless using the array indicies are used meaningfully.</p>"},{"location":"collections/lists/#appending-list-element-to-the-end-of-a-list","title":"Appending list element to the end of a list","text":"<p>To append to the end of a list, use the list method <code>append(elem)</code> function to add  <code>elem</code> to the end of a given list. <pre><code>bigger_list = [1,5,8,3,8,0,3]\n\nbigger_list.append(7)\n# bigger_list == [1,5,8,3,8,0,3,7]\n</code></pre></p>"},{"location":"collections/lists/#slicing-a-list","title":"Slicing a list","text":"<p>A list can be created from a previously created list by using the following syntax.</p> <p>Syntax</p> <ul> <li><code>example_list[:end]</code> =&gt; gets a list of elements from beginning of exampleList until index <code>end</code> (excluding element at index end)</li> <li><code>example_list[start:]</code> =&gt; gets a list of elements starting from index <code>start</code> (inclusive) until the end of exampleList</li> <li><code>example_list[start:end]</code> =&gt; gets a list of elements from exampleList starting from index <code>start</code> (inclusive) until the end index <code>end</code>(exclusive)</li> </ul> <p>Example: <pre><code>int_list = [1, 2, 3, 4, 5, 6]\n\nbegin_int_list = int_list[:2]\n# begin_int_list == [1,2]\n\nmiddle_int_list = int_list[2:4]\n# middle_int_list == [3,4]\n\nend_int_list = int_list[4:]\n# end_int_list == [5,6]\n</code></pre></p>"},{"location":"collections/lists/#popping-a-list-element-from-end-of-a-list","title":"Popping a list element from end of a list","text":"<p>To remove the last element of a given list (or \"pop\" it), use the <code>pop()</code> function. Note that this function also returns the item popped. <pre><code>bigger_list = [1,5,8,3,8,0,3]\n\npopped_item = bigger_list.pop()\n# bigger_list == [1,5,8,3,8,0]\n# popped_item == 3\n</code></pre></p>"},{"location":"collections/lists/#extending-a-list-with-another-list","title":"Extending a list with another list","text":"<p>To extend a list with another list (ie. concatenating the two lists), use the <code>extend</code> function: <pre><code>first_list = [2, 3, 5]\n# first_list == [2, 3, 5]\n\nsecond_list = [1, 4, 6]\nfirst_list.extend(second_list)\n# first_list == [2, 3, 5, 1, 4, 6]\n</code></pre></p>"},{"location":"collections/sets/","title":"Sets","text":"<p>Code sample link: https://replit.com/@jjoco/python-sets</p> <p>Sets are unordered (ie does not remember the insertion order) and unindexed (ie cannot read or write an element via an index) records of values. Python sets can be utilized like mathematical sets, as operations between sets are similar to that of mathematical sets (eg. intersections, unions, etc.). Each item in a set is unique, and fortunately, one can iterate through a set and can add items into it.</p>"},{"location":"collections/sets/#why-use-sets","title":"Why use sets","text":"<p>Sets in Python are highly optimized for reading and writing speed. When you check if a list contains some certain value, Python, at worst, would need to search through the entire list. On other hand, Python, at worst, would need to use a lookup table to figure out if an item exists in the set. To be more technical, time complexities for reading and writing values in a set is <code>O(1)</code>.</p>"},{"location":"collections/sets/#creating-a-set","title":"Creating a set","text":"<p>To create an empty set, you can use the <code>set()</code> function, or use curly braces like dictionaries. Keep in mind that Python will interpret empty curly braces as a dictionary; however, populated curly braces with items (that are not key-value pairs) will be interpreted as sets. <pre><code>#Create empty set\ninit_set = set()\nprint(init_set)\n'''\nPrints out:\nset()\n'''\n\n#Create a set using curly braces\nset_with_curly_braces = {\"hi\", \"there\", \"hello\"}\n\n#Create a set from an initial list\nset_from_list = set([\"hello\", \"world\", \"set\"])\nprint(set_from_list)\n'''\nPrints out:\n{'set', 'world', 'hello'}\n'''\n</code></pre></p>"},{"location":"collections/sets/#checking-if-a-set-contains-an-element","title":"Checking if a set contains an element","text":"<p>Use keyword <code>in</code> to check to see if a value exists in a set: <pre><code>#Check if element exists in set\ntarget = \"hello\"\nif target in set_with_curly_braces:\n  print(\"target is seen\")\n'''\nPrints out:\ntarget is seen\n'''\n</code></pre></p>"},{"location":"collections/sets/#pushing-an-element-into-a-set","title":"Pushing an element into a set","text":"<p>Use the <code>.add(elem)</code> method to add an item into a set: <pre><code>set_with_curly_braces.add(\"added_elem\")\nprint(set_with_curly_braces)\n'''\nPrints out:\n{'there', 'hi', 'hello', 'added_elem'}\n'''\n</code></pre></p>"},{"location":"collections/sets/#getting-the-length-of-a-set","title":"Getting the length of a set","text":"<p>You can use <code>len</code> to get the number elements in a set (ie. its length) . <pre><code>set_length = len(my_set)\n</code></pre> So, if <code>my_set = {'set', 'world', 'hello'}</code>, then <code>len(my_set)</code> would be <code>3</code>.</p>"},{"location":"collections/sets/#iterating","title":"Iterating","text":"<p>You can interate through a set like any other collection: <pre><code>for elem in set_with_curly_braces:\n  print(elem)\n'''\nPrints out:\nthere\nhi\nhello\nadded_elem\n'''\n</code></pre> Since sets are unordered, elements may be printed in a different order each time the for-loop is run.</p>"},{"location":"collections/sets/#clear-set","title":"Clear set","text":"<p>Use <code>.clear()</code> to remove all items in the set <pre><code>set_with_curly_braces.clear()\nprint(set_with_curly_braces)\n'''\nPrints out:\nset()\n'''\n</code></pre></p>"},{"location":"collections/sets/#set-operations","title":"Set operations","text":"<p>Like I alluded to before, set operations can be used between set operands. The following subsections will use the following sets in their examples: <pre><code>set_a = {5, 7, 3, 6 ,2 ,4, 1, 0}\nset_b = {5, 7, 3, 6 , 1, 0, 19}\nset_c = {5, 7, 3, 6 ,2 , 0}\n</code></pre></p>"},{"location":"collections/sets/#union","title":"Union","text":"<p>Given sets <code>A</code> and <code>B</code>, use <code>|</code> or <code>A.union(B)</code> to get the union of the two sets (ie a set of all distinct elements common or not common in the two sets)  <pre><code>print(set_a | set_b)\nprint(set_a.union(set_b))\n# Both print {0, 1, 2, 3, 4, 5, 6, 7, 19}\n</code></pre></p>"},{"location":"collections/sets/#intersection","title":"Intersection","text":"<p>Given sets <code>A</code> and <code>B</code>,  use <code>&amp;</code> or <code>A.intersection(B)</code> to get the intersection of the two sets (ie a set of all distincts elements common in the two sets)  <pre><code>print(set_a &amp; set_b)\nprint(set_a.intersection(set_b))\n# Both print {0, 1, 3, 5, 6, 7}\n</code></pre></p>"},{"location":"collections/sets/#difference","title":"Difference","text":"<p>Given sets <code>A</code> and <code>B</code>, use <code>-</code> or <code>A.difference(B)</code> to get the union of the two sets (ie a set of all elements in <code>A</code>, but not in <code>B</code>).  <pre><code>print(set_a - set_b)\nprint(set_a.difference(set_b))\n# Both print {2, 4}\n</code></pre></p>"},{"location":"collections/sets/#is-subset","title":"Is Subset","text":"<p>Given sets <code>A</code> and <code>B</code>, use <code>&lt;=</code> or <code>A.issubset(B)</code> to check if <code>A</code> is a subset of <code>B</code> (ie. all elements in <code>A</code> are contained in <code>B</code>) <pre><code>print(set_c &lt;= set_a)\nprint(set_c.issubset(set_a))\n# Both print True\n</code></pre></p>"},{"location":"collections/sets/#is-superset","title":"Is Superset","text":"<p>Given sets <code>A</code> and <code>B</code>, use <code>&gt;=</code> or <code>A.issuperset(B)</code> to check if <code>A</code> is a superset of <code>B</code> (ie. <code>A</code> contains all elements in <code>B</code>) <pre><code>print(set_a &gt;= set_c)\nprint(set_a.issuperset(set_c))\n# Both print True\n</code></pre></p>"},{"location":"collections/tuples/","title":"Tuples","text":"<p>Code sample link: https://replit.com/@jjoco/python-tuples</p> <p>Tuples, like lists, contain a record of values. Unlike lists, however, tuples cannot be changed after they have been created; you cannot remove or add more elements into a tuple.</p>"},{"location":"collections/tuples/#why-use-tuples","title":"Why use tuples","text":"<p>When we know what values are going to be in collection, it is generally better to use tuples than lists. Tuples are also generally faster and memory efficient to create and read than lists since tuples have constant size. Unlike lists, in which it is almost mandatory practice to have lists contain only one data type, it is an okay practice to have multiple types in a tuple. This is why each element in a <code>dictionary.items()</code> call is a 2-tuple, in which the key and value types may not coincide.</p> <p>So, if you wanted to maintain a running list of users with fields <code>age</code>, <code>name</code>, and <code>id</code>, you may not need to create a separate class for <code>User</code>. The list can look something like  <pre><code>[(25, \"justin\", 0), (38, \"jack\", 1), (35, \"jackie\", 2)]\n</code></pre> Since we know that the size of the tuples are constant, we can more easily process them.</p>"},{"location":"collections/tuples/#creating-a-tuple","title":"Creating a tuple","text":"<p>You can create a tuple using parentheses <code>()</code> like so: <pre><code>empty_tuple = ()\npacked_tuple = (2, 5 , 7, 3, 2, 1, 9)\n</code></pre> Keep in mind that if you make an empty tuple, you will not be able to change it.</p>"},{"location":"collections/tuples/#accessing-a-tuple-element","title":"Accessing a tuple element","text":"<p>Like lists, you can access a value or group of values via indexing: <pre><code>print(packed_tuple[1])\n\nprint(packed_tuple[1:5])\n</code></pre></p>"},{"location":"collections/tuples/#getting-the-length-of-a-tuple","title":"Getting the length of a tuple","text":"<p>To get the number of elements in a tuple (ie. its length), use the <code>len</code> function: <pre><code>tuple_length = len(my_tuple)\n</code></pre> So, if <code>my_tuple = (2, True, False, \"hello\")</code>, then <code>len(my_tuple)</code> would be <code>4</code>.</p>"},{"location":"collections/tuples/#unpacking-a-tuple","title":"Unpacking a tuple","text":"<p>Though it is not as common for lists and dictionaries to be unpacked, unpacking a tuple (ie assigning values within the tuple to external variables) is much more common due to its immutability: <pre><code>date_tuple = (\"04\", \"05\", \"2019\")\n\n(month, day, year) = date_tuple\nprint(month) \nprint(day) \nprint(year) \n'''\nPrints out:\n04\n05\n2019\n'''\n</code></pre> To continue on the example from before about a user_list, we can use unpacking to more easily process the user list: <pre><code>user_list = [(25, \"justin\", 0), (38, \"jack\", 1), (35, \"jackie\", 2)]\nfor age, name, id in user_list:\n  print(age)\n  print(name)\n  print(id)\n  print()\n'''\nPrints out:\n25\njustin\n0\n\n38\njack\n1\n\n35\njackie\n2\n'''\n</code></pre> Here, we unpack all three elements of the 3-tuple and can process them separately.</p> <p>Recall that when we process a dictionary's items using <code>dictionary.items()</code>, we use syntax: <pre><code>for some_key, some_val in some_map.items():\n    .\n    .\n    .\n</code></pre> This shows that the return value of <code>.items()</code> is a list of 2-tuples, and we're unpacking each 2-tuple item into <code>some_key</code> and <code>some_val</code>.</p>"},{"location":"oop/classes/","title":"Classes and Objects","text":"<p>Code links: https://replit.com/@jjoco/python-classes</p> <p>Classes are blueprints of objects or data structures. Objects of a class contain their own attributes(or fields) and functions (or methods).</p> <p>Python supplies many basic types and data structures; however, these are all very generic and would not be useful by themselves if the developer wants to do something specific for in their program. This is where classes come in.</p> <p>Let's say I wanted to create a program involving rectangles and their operations. We can create a blueprint for rectangles by creating a new class, and when we want to create new rectangles for our program, we can create new instances (or objects) of that <code>Rectangle</code> class. Each <code>Rectangle</code> object would have common field names and common methods, which makes code implementation easier and reusable.</p> <p>The programming paradigm of creating and manipulating objects and classes is called \"object-oriented programming\" (OOP).</p>"},{"location":"oop/classes/#creating-a-class","title":"Creating a class","text":"<p>To create a new class, you can use the <code>class</code> keyword: <pre><code>class MyClass:\n    .\n    .\n    .\n</code></pre></p>"},{"location":"oop/classes/#constructor-and-instance-methods","title":"Constructor and instance methods","text":"<p>Though it's not mandatory, most classes implement the constructor method <code>__init__(self, ...)</code>, which sets the initial state of a newly created object of a given class:</p> <pre><code>class MyClass:\n    def __init__(self, *args):\n        .\n        .\n        .\n</code></pre> <p>The dev can create other methods for the class in addition to the constructor: <pre><code>class MyClass:\n\n    .\n    .\n    .\n    def my_method(self, ...):\n        .\n        .\n        .\n</code></pre> You may have noticed that first argument of any class's instance method is <code>self</code>. This argument references the current instance of the class, and <code>self</code> is Python's naming convention for this parameter.</p> <p>Let's go through a more thorough example. In the following example, we create a <code>Rectangle</code> class: <pre><code>class Rectangle:\n    def __init__(self, width: int,  length: int):\n        self.width = width\n        self.length = length\n\n    def get_area(self) -&gt; int:\n        return self.width * self.length\n</code></pre> This class contains the blueprint for creating a <code>Rectangle</code> object. In our constructor, we're setting the initial width and length of the <code>Rectangle</code> object to whatever the caller has specified. We have a <code>get_area()</code> function that calculates the <code>Rectangle</code> object's area based upon the object's <code>width</code> and <code>length</code> field values.</p>"},{"location":"oop/classes/#creating-instance-of-class-ie-object","title":"Creating instance of class (ie object)","text":"<p>To create a new object (or instance) of the <code>Rectangle</code> class, we can do the following: <pre><code>rect = Rectangle(5, 6)\n\nprint(rect.get_area())\n# Output = 30\n</code></pre> In the above code block, we create a new <code>Rectangle</code>, whose initial width and length are 5 and 6, respectively. Then, we invoke the <code>.get_area()</code> function, which returns us the calculated area of the rectangle, which in this case is <code>30</code>.</p>"},{"location":"oop/classes/#private-methods-and-fields","title":"Private methods and fields","text":"<p>Unlike other object-oriented programming (OOP) languages, all class fields and functions are public (ie can be read or written directly by external callers). The dev can write the fields and methods as if to treat them like they are private (ie cannot be read or written directly by external callers) by prepending an underscore <code>_</code> to field names and methods. Take the following <code>Rectangle</code> class rewritten to have \"private\" fields and methods: <pre><code>class Rectangle:\n    def __init__(self, width: int,  length: int):\n        self._width = width\n        self._length = length\n        self._area = -1\n\n    def _calculate_area(self):\n        return self._width * self._length\n\n    def get_area(self) -&gt; int:\n        if self._area &lt;= 0:\n            self._area = self._calculate_area()\n\n        return self._area\n</code></pre> This class is written such that external callers should only be able to <code>get_area()</code>; however, Python does not stop an external caller from calling <code>_calculate_area()</code> or changing <code>_width</code> or <code>_length</code>.</p> <p>However, if the class is written to have private fields or methods, the dev can write setters and getters to indirectly access those fields: <pre><code>class Rectangle:\n    def __init__(self, width: int,  length: int):\n        self._width = width\n        self._length = length\n\n    def set_width(self, width: int) -&gt; None:\n        self._width = width\n\n    def set_length(self, length: int) -&gt; None:\n        self._length = length\n\n    def get_width(self) -&gt; int:\n        return self._width\n\n    def get_length(self) -&gt; int:\n        return self._length\n\n# Calling\nrect = Rectangle(5, 7)\nprint(rect.get_width()) # width == 5\nrect.set_width(8)\nprint(rect.get_width()) # width == 8\n</code></pre> As you can see, it can be a bit verbose to write setters and getters this way. Luckily, Python has some handy annotations that'll allow you to write setters and getters more cleanly, but that's outside the scope of this tutorial.</p>"},{"location":"oop/inheritance/","title":"Inheritance","text":"<p>Code sample link: https://replit.com/@jjoco/python-inheritance</p> <p>Class inheritance is how we can derive a class (called the derived, child, or subclass) from another class (called the base, parent, or superclass). Classes dervied from some base class maintain some, if not many, characteristics of the base class, but does something a bit differently that warrants the creation of a whole new class.</p>"},{"location":"oop/inheritance/#why-use-inheritance","title":"Why use inheritance","text":"<p>Let's say we have a <code>Rectangle</code> class that has fields <code>width</code> and <code>length</code>. Let's say we wanted to create a rectangle whose width and length are the same. <pre><code>rect = Rectangle(6 , 6)\n</code></pre> There's nothing wrong with setting a rectangle with equivalent width and length; however, it will be annoying for the caller to keep on writing <code>Rectangle(some_number , some_number)</code> if there will be a lot of these type of rectangles. To resolve this, we can write a new <code>Square</code> class, which is a rectangle with equivalent <code>width</code> and <code>length</code>.</p>"},{"location":"oop/inheritance/#inheritance-at-work","title":"Inheritance at work","text":"<p>Let's take the simple implementation of the <code>Rectangle</code> class from the previous section: <pre><code>class Rectangle:\n  def __init__(self, width: float, length: float) -&gt; None:\n    self.width = width\n    self.length = length\n\n  def get_area(self) -&gt; float:\n    return self.width * self.length\n\n  def get_dimensions(self) -&gt; tuple:\n    return (self.width, self.length)\n</code></pre> We can create a child class <code>Square</code> using the following syntax: <pre><code>class DerivedClass(BaseClass):\n  .\n  .\n  .\n</code></pre></p> <p>We will need to use the <code>super()</code> function in the derived class's constructor to gain access to the base class's fields and methods: <pre><code>class Square(Rectangle):\n  def __init__(self, side):\n    super().__init__(side, side)\n    self.side = side\n\n  def get_side(self):\n    return self.side\n</code></pre> Here, we are feeding the <code>side</code> parameter of the <code>Square</code> as both parameters of the base class's constructor. This allows us to call <code>Rectangle</code>'s <code>get_dimensions()</code> and <code>get_area()</code> methods without needing to re-implement them.</p> <p>We also add a <code>get_side()</code> method to access the <code>side</code> field of the square.</p> <p>Take the following calling example: <pre><code>my_sq = Square(5)\nprint(my_sq.get_area()) # Returns 25\nprint(my_sq.get_dimensions()) # Returns (5, 5)\nprint(my_sq.get_side())  # Returns 5\n</code></pre> Even though we didn't re-implement <code>get_area()</code> or <code>get_dimensions()</code> we could still call those functions since <code>Square</code> is a <code>Rectangle</code> and <code>Square</code> can access <code>Rectangle</code>'s methods. However, we can re-implement a base class method, if we want: <pre><code>class Square(Rectangle):\n  def __init__(self, side):\n    super().__init__(side, side)\n    self.side = side\n\n  def get_dimensions(self):\n    return self.side\n</code></pre> Here, I rename the original <code>get_side()</code> method into <code>get_dimensions()</code>, allowing <code>Square</code>'s implementation to take precendence over <code>Rectangle</code>'s: <pre><code>my_sq = Square(6)\nprint(my_sq.get_area()) # Returns \nprint(my_sq.get_dimensions()) # Returns 6\n</code></pre></p>"},{"location":"utils/chr_ord/","title":"chr() and ord()","text":"<p>Code sample link: https://replit.com/@justinjoco/python-chr-ord</p> <p>These utility functions are useful for coverting unicode characters to and from their code point values. This table contains some, but not all, of the character-code point mappings: https://www.rapidtables.com/code/text/ascii-table.html</p>"},{"location":"utils/chr_ord/#chr","title":"<code>chr</code>","text":"<p>The <code>chr</code> function takes an integer argument and returns the appropriate unicode character for that number.  <pre><code>chr(61) == '='\nchr(100) == 'd'\nchr(101) == 'e'\nchr(102) == 'f'\nchr(103) == 'g'\n</code></pre></p>"},{"location":"utils/chr_ord/#ord","title":"<code>ord</code>","text":"<p>The <code>ord</code> function takes a unicode string argument and returns the corresponding code point value. <pre><code>ord(\"(\") == 40\nord(\"&lt;\") == 60\nord(\"A\") == 65\nord(\"9\") == 57\n</code></pre></p>"},{"location":"utils/chr_ord/#convert-a-lowercase-letter-to-an-index-between-0-and-25-inclusive","title":"Convert a lowercase letter to an index between 0 and 25, inclusive","text":"<p>Use the statement <code>ord(char) - ord(\"a\")</code> <pre><code>ord(\"a\") - ord(\"a\") == 0\nord(\"z\") - ord(\"a\") == 25\nord(\"d\") - ord(\"a\") == 3\nord(\"j\") - ord(\"a\") == 9\n</code></pre></p>"},{"location":"utils/functional/","title":"Map, Filter, Reduce","text":"<p>Code sample link: https://replit.com/@jjoco/python-functional</p> <p>These functions help the developer take a more functional approach to some problems.</p> <p>Let's say we have an <code>items</code> list: <pre><code>items = [0 , -1, -5, 3, 5, 6, 2, 1]\n</code></pre></p>"},{"location":"utils/functional/#map","title":"<code>map</code>","text":"<p>The <code>map</code> function allows the developer to apply a function to all items in a list, and returns an iterator that contains the output values.</p> <p>Syntax <pre><code>map_iterator = map(map_func, base_list)\n</code></pre></p> <p>Check out the following: <pre><code>squared = list(map(lambda x: x**2, items))\nprint(squared) #[0, 1, 25, 9, 25, 36, 4, 1]\n</code></pre> Note that <code>list</code> is needed to cast the iterator into a list. In this example, we create multiply each value in <code>items</code> by 2, and put the output results in a new list. FYI, you could also do the above using list comprehensions.</p>"},{"location":"utils/functional/#filter","title":"<code>filter</code>","text":"<p><code>filter</code> creates a new list that contains the values of some base list based on some condition function.</p> <p>Syntax <pre><code>filtered_iter = filter(condition_func, items)\n</code></pre></p> <p>For example, <pre><code>filtered = list(filter(lambda x: x &lt; 0, items))\nprint(filtered) # 11\n</code></pre> Here, we filter out anything in <code>items</code> that is not negative. </p>"},{"location":"utils/functional/#reduce","title":"<code>reduce</code>","text":"<p><code>reduce</code> is used to do some computation on an entire list, instead of each element separately. It performs a rolling computation on sequential pairs in the list in order to accumulate the elements into a single value.</p> <p>Firstly, we need to import <code>reduce</code> from the <code>functools</code> library and use the following syntax: <pre><code>from functools import reduce\nresult = reduce(reduce_func, items)\n</code></pre></p> <p>Consider the following: <pre><code>from functools import reduce\n\ntotal = reduce(lambda acc, nextVal : acc + nextVal, items)\nprint(total) # 11\n</code></pre> In the above example, we use <code>reduce</code> to get the sum of the given <code>items</code> list. </p>"},{"location":"utils/lambdas/","title":"Lambdas","text":"<p>Code sample link: https://replit.com/@jjoco/python-lambdas</p> <p>Lambda functions can be thought of short-term, concise, impromptu functions that are intended to be thrown away after one or a couple of uses.</p>"},{"location":"utils/lambdas/#why-use-lambda-functions","title":"Why use lambda functions","text":"<p>Lambdas are commonly used in other functions that have functions as parameters (ie higher-order functions).</p>"},{"location":"utils/lambdas/#creating-a-standalone-lambda-function","title":"Creating a standalone-lambda function","text":"<p>You can create lambda functions to implement very concise one-line functions. Use the keyword <code>lambda</code> to create a function. Syntax: <pre><code>lamdba_func = lambda args: return_value\n</code></pre></p> <p>Let's go over a more concrete example: <pre><code>double_funct = lambda x: x * 2\nprint(double_funct(5))\n\nadd_funct = lambda x, y: x + y\nprint(add_funct(5, 7))\n</code></pre> In the above, we create two lambda functions, whose names are <code>double_funct</code> and <code>add_funct</code>. These lambda functions are used like any other function. In this example, we're using <code>lambda</code> to implement very short functions, whose scope is narrowed to the current code block.</p>"},{"location":"utils/lambdas/#creating-a-lambda-generator-function","title":"Creating a lambda generator function","text":"<p>What is cool is that we can create a lambda generator, which we can use to easily create more lambda functions on demand: <pre><code>def exp_funct(n):\n  return lambda x : x ** n\n\nsquare_funct = exp_funct(2)\nprint(square_funct(5))\n\ncube_funct = exp_funct(3)\nprint(cube_funct(5))\n</code></pre> Here, we are using <code>exp_funct</code> to generate lambda functions that raise an input to the n-th power.</p>"},{"location":"utils/lambdas/#using-lambda-functions-as-inputs-to-other-functions","title":"Using lambda functions as inputs to other functions","text":"<p>Lambda functions are commonly used as inputs to functions, whose required (or optional) parameters are also functions.</p> <p>Take the following example: <pre><code>card_map = {\"king\": 13, \"jack\": 11, \"queen\": 12, \"ace\": 1}\nprint(card_map) # {'king': 13, 'jack': 11, 'queen': 12, 'ace': 1}\n\nsorted_list = sorted(card_map.items(), key=lambda item: item[1])\nprint(sorted_list) # [('ace', 1), ('jack', 11), ('queen', 12), ('king', 13)]\n\nsorted_map = dict(sorted_list)\nprint(sorted_map) # {'ace': 1, 'jack': 11, 'queen': 12, 'king': 13}\n</code></pre> Here, we are using a lambda function in <code>sorted</code> to define how to sort the key values pairs in <code>card_map</code>. Specifically, we're sorting key-value pairs in <code>card_map</code> by the values. Then we're taking the list of 2-tuples in <code>sorted_list</code> and turning it into a dictionary.</p>"}]}